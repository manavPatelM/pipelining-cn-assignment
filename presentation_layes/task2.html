<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Text Compression Toolkit</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        /* Animated background elements */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 118, 117, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 226, 0.3) 0%, transparent 50%);
            animation: float 20s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes float {
            0%, 100% { transform: translate(-50px, -50px) rotate(0deg); }
            50% { transform: translate(50px, 50px) rotate(180deg); }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.2);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 30%, #bae6fd 60%, #dbeafe 100%);
            color: #0c4a6e;
            padding: 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
            border-bottom: 3px solid #0ea5e9;
            box-shadow: 0 4px 20px rgba(14, 165, 233, 0.15);
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                url("data:image/svg+xml,%3Csvg width='100' height='20' viewBox='0 0 100 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m0 10c10-8 30-8 40 0s30 8 40 0 30-8 40 0' stroke='%2338bdf8' stroke-width='1' fill='none' stroke-opacity='0.1'/%3E%3C/svg%3E") repeat-x;
            animation: oceanWave 15s linear infinite;
        }

        @keyframes oceanWave {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100px); }
        }

        .header-content {
            position: relative;
            z-index: 1;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 12px;
            text-shadow: none;
            font-weight: 700;
            letter-spacing: -1px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            color: #0369a1;
        }

        .header-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #0ea5e9, #3b82f6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            border: 2px solid rgba(14, 165, 233, 0.2);
            backdrop-filter: blur(10px);
            color: white;
            box-shadow: 0 8px 25px rgba(14, 165, 233, 0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.8;
            font-weight: 300;
            margin-top: 10px;
            color: #075985;
        }

        .main-content {
            padding: 50px 40px;
        }

        .algorithm-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .algorithm-btn {
            padding: 16px 32px;
            border: 2px solid transparent;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            color: #495057;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            font-size: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .algorithm-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #3498db, #9b59b6);
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: -1;
        }

        .algorithm-btn:hover::before,
        .algorithm-btn.active::before {
            left: 0;
        }

        .algorithm-btn:hover,
        .algorithm-btn.active {
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.3);
        }

        .algorithm-info {
            background: linear-gradient(135deg, #e8f4f8, #f0f8ff);
            border: none;
            border-left: 5px solid #3498db;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.1);
            position: relative;
            overflow: hidden;
        }

        .algorithm-info::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(52, 152, 219, 0.1), transparent);
            border-radius: 50%;
            transform: translate(25px, -25px);
        }

        .input-section {
            margin-bottom: 35px;
        }

        .input-section label {
            display: block;
            margin-bottom: 12px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.2rem;
            position: relative;
        }

        .input-section label::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 50px;
            height: 3px;
            background: linear-gradient(135deg, #3498db, #9b59b6);
            border-radius: 2px;
        }

        .input-textarea {
            width: 100%;
            min-height: 180px;
            padding: 20px;
            border: 2px solid rgba(52, 152, 219, 0.2);
            border-radius: 16px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
        }

        .input-textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.1);
            background: rgba(255, 255, 255, 0.95);
            transform: scale(1.01);
        }

        .action-buttons {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 16px 36px;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            min-width: 160px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.3);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            pointer-events: none;
            transform: none !important;
        }

        .btn-loading {
            position: relative;
        }

        .btn-loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid transparent;
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .results-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        @media (max-width: 768px) {
            .results-section {
                grid-template-columns: 1fr;
            }
        }

        .result-box {
            background: linear-gradient(135deg, rgba(248, 249, 250, 0.9), rgba(233, 236, 239, 0.9));
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 25px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .result-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s;
        }

        .result-box:hover::before {
            left: 100%;
        }

        .result-box:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.1);
        }

        .result-box h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
        }

        .result-content {
            font-family: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(222, 226, 230, 0.5);
            min-height: 120px;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 13px;
            line-height: 1.6;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .result-content:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: scale(1.02);
        }

        /* Compression/Decompression Animation */
        .processing {
            position: relative;
        }

        .processing::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(52, 152, 219, 0.3) 50%,
                transparent 100%
            );
            animation: processing 1.5s ease-in-out infinite;
            border-radius: 12px;
        }

        .processing::after {
            content: '⚡ Processing...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            backdrop-filter: blur(10px);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes processing {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        .stats-section {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 35px;
            border-radius: 20px;
            margin-top: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 25px;
        }

        .stat-item {
            text-align: center;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));
            backdrop-filter: blur(10px);
            padding: 30px 20px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(135deg, #3498db, #9b59b6);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }

        .stat-item:hover::before {
            transform: scaleX(1);
        }

        .stat-item:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 40px rgba(52, 152, 219, 0.2);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #3498db, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: block;
            margin-bottom: 8px;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.95rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .copy-btn {
            background: linear-gradient(135deg, #6c757d, #495057);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            margin-left: 12px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .copy-btn:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, #495057, #343a40);
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }

        .error {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb) !important;
            border-color: #f5c6cb !important;
            color: #721c24 !important;
        }

        .success {
            background: linear-gradient(135deg, #d4edda, #c3e6cb) !important;
            border-color: #c3e6cb !important;
            color: #155724 !important;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .main-content {
                padding: 30px 20px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
                flex-direction: column;
                gap: 10px;
            }
            
            .algorithm-selector,
            .action-buttons {
                justify-content: center;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>
                    <div class="header-icon">🗜️</div>
                    Text Compression Toolkit
                </h1>
                <p>Advanced compression algorithms with real-time processing animations</p>
            </div>
        </div>

        <div class="main-content">
            <div class="algorithm-selector">
                <button class="algorithm-btn active" data-algorithm="rle">Run-Length Encoding</button>
                <button class="algorithm-btn" data-algorithm="huffman">Huffman Coding</button>
                <button class="algorithm-btn" data-algorithm="deflate">DEFLATE Algorithm</button>
            </div>

            <div class="algorithm-info" id="algorithmInfo">
                <strong>Run-Length Encoding (RLE):</strong> A simple lossless compression technique that replaces consecutive repeated characters with the character followed by its count. Most effective for data with many consecutive repeated elements like "AAABBCC" → "3A2B2C".
            </div>

            <div class="input-section">
                <label for="inputText">Input Text:</label>
                <textarea id="inputText" class="input-textarea" placeholder="Enter text to compress or decompress...">AAABBBBBCCCCCDDDDDDDEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHHHIIIIIIIIIJJJJJJJJJJ</textarea>
            </div>

            <div class="action-buttons">
                <button class="btn btn-primary" onclick="compressText()" id="compressBtn">
                    🔄 Compress
                </button>
                <button class="btn btn-secondary" onclick="decompressText()" id="decompressBtn">
                    🔓 Decompress
                </button>
                <button class="btn btn-success" onclick="clearAll()">
                    🧹 Clear All
                </button>
            </div>

            <div class="results-section">
                <div class="result-box">
                    <h3>
                        📦 Compressed Output
                        <button class="copy-btn" onclick="copyToClipboard('compressedResult')">Copy</button>
                    </h3>
                    <div id="compressedResult" class="result-content"></div>
                </div>

                <div class="result-box">
                    <h3>
                        🎯 Decompressed Output
                        <button class="copy-btn" onclick="copyToClipboard('decompressedResult')">Copy</button>
                    </h3>
                    <div id="decompressedResult" class="result-content"></div>
                </div>
            </div>

            <div class="stats-section">
                <div class="stats-grid">
                    <div class="stat-item">
                        <span id="originalSize" class="stat-value">0</span>
                        <div class="stat-label">Original Size (bytes)</div>
                    </div>
                    <div class="stat-item">
                        <span id="compressedSize" class="stat-value">0</span>
                        <div class="stat-label">Compressed Size (bytes)</div>
                    </div>
                    <div class="stat-item">
                        <span id="compressionRatio" class="stat-value">0%</span>
                        <div class="stat-label">Compression Ratio</div>
                    </div>
                    <div class="stat-item">
                        <span id="spaceSaved" class="stat-value">0</span>
                        <div class="stat-label">Space Saved (bytes)</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentAlgorithm = 'rle';
        let huffmanTree = null;
        let compressionData = null;

        // Algorithm information
        const algorithmInfo = {
            rle: "Run-Length Encoding (RLE): A simple lossless compression technique that replaces consecutive repeated characters with the character followed by its count. Most effective for data with many consecutive repeated elements like \"AAABBCC\" → \"3A2B2C\".",
            huffman: "Huffman Coding: A lossless compression algorithm that assigns variable-length codes to characters based on their frequency. More frequent characters get shorter codes, achieving optimal compression for the given frequency distribution.",
            deflate: "DEFLATE Algorithm: A combination of LZ77 and Huffman coding used in ZIP files and gzip. First applies LZ77 to find repeated sequences, then uses Huffman coding on the resulting data for maximum compression efficiency."
        };

        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.algorithm-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.algorithm-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentAlgorithm = this.dataset.algorithm;
                    updateAlgorithmInfo();
                    clearResults();
                });
            });
        });

        function updateAlgorithmInfo() {
            document.getElementById('algorithmInfo').innerHTML = `<strong>${getAlgorithmName(currentAlgorithm)}:</strong> ${algorithmInfo[currentAlgorithm]}`;
        }

        function getAlgorithmName(algorithm) {
            const names = {
                rle: "Run-Length Encoding (RLE)",
                huffman: "Huffman Coding",
                deflate: "DEFLATE Algorithm"
            };
            return names[algorithm];
        }

        // Run-Length Encoding Implementation
        class RLE {
            static compress(text) {
                if (!text) return '';
                
                let result = '';
                let count = 1;
                
                for (let i = 0; i < text.length; i++) {
                    if (i + 1 < text.length && text[i] === text[i + 1]) {
                        count++;
                    } else {
                        if (count > 1) {
                            result += count + text[i];
                        } else {
                            result += text[i];
                        }
                        count = 1;
                    }
                }
                
                return result;
            }

            static decompress(compressed) {
                if (!compressed) return '';
                
                let result = '';
                let i = 0;
                
                while (i < compressed.length) {
                    if (i + 1 < compressed.length && /\d/.test(compressed[i])) {
                        // Check if it's a number followed by a character
                        let numStr = '';
                        while (i < compressed.length && /\d/.test(compressed[i])) {
                            numStr += compressed[i];
                            i++;
                        }
                        
                        if (i < compressed.length) {
                            const count = parseInt(numStr);
                            const char = compressed[i];
                            result += char.repeat(count);
                            i++;
                        }
                    } else {
                        result += compressed[i];
                        i++;
                    }
                }
                
                return result;
            }
        }

        // Huffman Coding Implementation
        class HuffmanNode {
            constructor(char, freq) {
                this.char = char;
                this.freq = freq;
                this.left = null;
                this.right = null;
            }
        }

        class Huffman {
            static buildFrequencyTable(text) {
                const freq = {};
                for (let char of text) {
                    freq[char] = (freq[char] || 0) + 1;
                }
                return freq;
            }

            static buildHuffmanTree(freq) {
                const nodes = Object.entries(freq).map(([char, frequency]) => new HuffmanNode(char, frequency));
                
                if (nodes.length === 1) {
                    const root = new HuffmanNode(null, nodes[0].freq);
                    root.left = nodes[0];
                    return root;
                }
                
                while (nodes.length > 1) {
                    nodes.sort((a, b) => a.freq - b.freq);
                    const left = nodes.shift();
                    const right = nodes.shift();
                    
                    const merged = new HuffmanNode(null, left.freq + right.freq);
                    merged.left = left;
                    merged.right = right;
                    
                    nodes.push(merged);
                }
                
                return nodes[0];
            }

            static generateCodes(root) {
                const codes = {};
                
                function traverse(node, code = '') {
                    if (node.char !== null) {
                        codes[node.char] = code || '0';
                        return;
                    }
                    
                    if (node.left) traverse(node.left, code + '0');
                    if (node.right) traverse(node.right, code + '1');
                }
                
                traverse(root);
                return codes;
            }

            static compress(text) {
                if (!text) return { compressed: '', tree: null };
                
                const freq = this.buildFrequencyTable(text);
                const tree = this.buildHuffmanTree(freq);
                const codes = this.generateCodes(tree);
                
                let binaryString = '';
                for (let char of text) {
                    binaryString += codes[char];
                }
                
                // Convert binary string to base64 for display
                const compressed = this.binaryToBase64(binaryString);
                
                return { 
                    compressed: compressed, 
                    tree: tree,
                    binaryString: binaryString,
                    codes: codes
                };
            }

            static decompress(compressedData, tree, originalLength) {
                if (!compressedData || !tree) return '';
                
                const binaryString = this.base64ToBinary(compressedData);
                let result = '';
                let current = tree;
                let bitCount = 0;
                
                for (let bit of binaryString) {
                    if (result.length >= originalLength) break;
                    
                    current = bit === '0' ? current.left : current.right;
                    bitCount++;
                    
                    if (current && current.char !== null) {
                        result += current.char;
                        current = tree;
                    }
                }
                
                return result;
            }

            static binaryToBase64(binary) {
                // Pad binary string to multiple of 6 for base64 conversion
                while (binary.length % 6 !== 0) {
                    binary += '0';
                }
                
                let result = '';
                for (let i = 0; i < binary.length; i += 6) {
                    const chunk = binary.substr(i, 6);
                    const value = parseInt(chunk, 2);
                    result += 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'[value];
                }
                
                return result;
            }

            static base64ToBinary(base64) {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                let binary = '';
                
                for (let char of base64) {
                    const value = chars.indexOf(char);
                    if (value !== -1) {
                        binary += value.toString(2).padStart(6, '0');
                    }
                }
                
                return binary;
            }
        }

        // Simple DEFLATE-like implementation (simplified version)
        class Deflate {
            static compress(text) {
                if (!text) return { compressed: '', metadata: null };
                
                // Simplified DEFLATE: just use Huffman coding for this demo
                const huffmanResult = Huffman.compress(text);
                
                return {
                    compressed: huffmanResult.compressed,
                    metadata: {
                        huffman: {
                            tree: huffmanResult.tree,
                            codes: huffmanResult.codes,
                            originalLength: text.length
                        }
                    }
                };
            }

            static decompress(compressed, metadata) {
                if (!compressed || !metadata) return '';
                
                return Huffman.decompress(
                    compressed, 
                    metadata.huffman.tree, 
                    metadata.huffman.originalLength
                );
            }
        }

        function compressText() {
            const inputText = document.getElementById('inputText').value;
            if (!inputText.trim()) {
                alert('Please enter some text to compress!');
                return;
            }

            // Add processing animation to compressed result box
            const compressedResultBox = document.getElementById('compressedResult');
            compressedResultBox.classList.add('processing');
            compressedResultBox.textContent = '';

            // Disable button and add loading state
            const compressBtn = document.getElementById('compressBtn');
            compressBtn.disabled = true;
            compressBtn.classList.add('btn-loading');
            compressBtn.innerHTML = '';

            setTimeout(() => {
                try {
                    let compressed;
                    const originalSize = new TextEncoder().encode(inputText).length;
                    
                    switch (currentAlgorithm) {
                        case 'rle':
                            compressed = RLE.compress(inputText);
                            compressionData = null;
                            break;
                        case 'huffman':
                            const huffmanResult = Huffman.compress(inputText);
                            compressed = huffmanResult.compressed;
                            compressionData = {
                                tree: huffmanResult.tree,
                                originalLength: inputText.length,
                                codes: huffmanResult.codes
                            };
                            break;
                        case 'deflate':
                            const deflateResult = Deflate.compress(inputText);
                            compressed = deflateResult.compressed;
                            compressionData = deflateResult.metadata;
                            break;
                    }

                    compressedResultBox.textContent = compressed;
                    compressedResultBox.classList.remove('error', 'processing');
                    
                    const compressedSize = new TextEncoder().encode(compressed).length;
                    updateStats(originalSize, compressedSize);
                    
                } catch (error) {
                    compressedResultBox.textContent = 'Error: ' + error.message;
                    compressedResultBox.classList.add('error');
                    compressedResultBox.classList.remove('processing');
                } finally {
                    // Restore button state
                    compressBtn.disabled = false;
                    compressBtn.classList.remove('btn-loading');
                    compressBtn.innerHTML = '🔄 Compress';
                }
            }, 1200);
        }

        function decompressText() {
            const compressedText = document.getElementById('compressedResult').textContent;
            if (!compressedText.trim() || compressedText.startsWith('Error:')) {
                alert('Please compress some text first!');
                return;
            }

            // Add processing animation to decompressed result box
            const decompressedResultBox = document.getElementById('decompressedResult');
            decompressedResultBox.classList.add('processing');
            decompressedResultBox.textContent = '';

            // Disable button and add loading state
            const decompressBtn = document.getElementById('decompressBtn');
            decompressBtn.disabled = true;
            decompressBtn.classList.add('btn-loading');
            decompressBtn.innerHTML = '';

            setTimeout(() => {
                try {
                    let decompressed;

                    switch (currentAlgorithm) {
                        case 'rle':
                            decompressed = RLE.decompress(compressedText);
                            break;
                        case 'huffman':
                            if (!compressionData || !compressionData.tree) {
                                throw new Error('Huffman tree not available. Please compress first.');
                            }
                            decompressed = Huffman.decompress(
                                compressedText, 
                                compressionData.tree, 
                                compressionData.originalLength
                            );
                            break;
                        case 'deflate':
                            if (!compressionData) {
                                throw new Error('Compression metadata not available. Please compress first.');
                            }
                            decompressed = Deflate.decompress(compressedText, compressionData);
                            break;
                    }

                    decompressedResultBox.textContent = decompressed;
                    decompressedResultBox.classList.remove('error', 'processing');
                    decompressedResultBox.classList.add('success');
                    
                } catch (error) {
                    decompressedResultBox.textContent = 'Error: ' + error.message;
                    decompressedResultBox.classList.add('error');
                    decompressedResultBox.classList.remove('success', 'processing');
                } finally {
                    // Restore button state
                    decompressBtn.disabled = false;
                    decompressBtn.classList.remove('btn-loading');
                    decompressBtn.innerHTML = '🔓 Decompress';
                }
            }, 1000);
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            clearResults();
        }

        function clearResults() {
            document.getElementById('compressedResult').textContent = '';
            document.getElementById('decompressedResult').textContent = '';
            document.getElementById('compressedResult').classList.remove('error', 'success', 'processing');
            document.getElementById('decompressedResult').classList.remove('error', 'success', 'processing');
            compressionData = null;
            updateStats(0, 0);
        }

        function updateStats(originalSize, compressedSize) {
            const compressionRatio = originalSize > 0 ? ((originalSize - compressedSize) / originalSize * 100).toFixed(1) : 0;
            const spaceSaved = Math.max(0, originalSize - compressedSize);

            // Animate the numbers
            animateValue('originalSize', 0, originalSize, 800);
            animateValue('compressedSize', 0, compressedSize, 800);
            animateValue('spaceSaved', 0, spaceSaved, 800);
            
            setTimeout(() => {
                document.getElementById('compressionRatio').textContent = compressionRatio + '%';
            }, 400);
        }

        function animateValue(id, start, end, duration) {
            const element = document.getElementById(id);
            const startTime = performance.now();
            
            function update(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const current = Math.floor(start + (end - start) * progress);
                element.textContent = current;
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            requestAnimationFrame(update);
        }

        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            
            if (!text.trim()) {
                alert('Nothing to copy!');
                return;
            }

            navigator.clipboard.writeText(text).then(function() {
                const btn = element.parentElement.querySelector('.copy-btn');
                const originalText = btn.textContent;
                btn.textContent = '✓ Copied!';
                btn.style.background = 'linear-gradient(135deg, #27ae60, #229954)';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'linear-gradient(135deg, #6c757d, #495057)';
                }, 2000);
            }).catch(function(err) {
                console.error('Could not copy text: ', err);
                alert('Copy failed. Please select and copy manually.');
            });
        }

        // Initialize
        window.addEventListener('load', function() {
            updateAlgorithmInfo();
        });
    </script>
</body>
</html>
